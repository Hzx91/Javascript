<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <title>自定义滑动滚轮案例</title>
        <style>
            * {
                margin: 0;
                padding: 0;
            }
            #box {
                position: relative;
                margin: 100px auto;
                width: 300px;
                height: 400px;
                box-shadow: -2px -2px 6px #3b3b3b;
                /* overflow: hidden; */
            }
            #box div {
                position: absolute;
            }
            #con {
                font-size: 13px;
                text-align: justify;
                padding: 5px 15px 5px 5px;
            }
            #scroll {
                width: 15px;
                height: 100%;
                background-color: #a8a6a6;
                right: 0;
            }
            #bar {
                width: 100%;
                height: 80px;
                background-color: rgb(32, 31, 31);
                border-radius: 5px;
            }
        </style>
    </head>
    <body>
        <!-- 
            思路：
             1.静态的实现
                1.1 HTML：box里面嵌套con和scroll，scroll嵌套bar
                1.2 
                    CSS：
                        1.1.1   给box设置高宽和相对定位，不会脱标，所以可以设置margin:0 auto ！！！且在父元素中设置overflow才会生效
                        1.1.2   con盒子text-align: justify;文字两端对齐，以及设置padding可以给右边腾出滚动条的位置，不至于滚动条会覆盖文字
                        1.1.3   scroll不需要设置宽度heigh：100%即可，就不需要去计算父元素的总体高度，并且con设置的padding不会影响到他的right偏移值
                        1.1.4   bar盒子不需单独设置width数量，100%即可。

        -->
        <div id="box">
            <div id="con">
                #### 6.5 总结

- **函数名**：是一个变量，作用是在当前作用域中 “标记” 函数引用，方便访问。

- **函数引用**：是函数在内存中的实际标识（指针），决定了函数的唯一性。

- 关系：函数名存储函数引用，就像 “变量存储值” 一样。

  理解这一点，就能明白为什么事件监听的添加和移除必须使用同一个函数引用（而非仅仅同名）—— 因为 JS 只认内存中的函数实体，不认名字。

- `addEventListener` 这个方法的**返回值就是 `undefined`**。

  具体来说：
  `window.addEventListener("resize", fn, false)` 的作用是 “给窗口添加 `resize` 事件监听”，它的设计目的是 “执行一个操作”（绑定事件），而不是 “返回一个结果”。所以调用它之后，浏览器会完成事件绑定的工作，但不会返回任何有意义的值，自然就输出 `undefined` 了。

  这和数学中的 “函数” 不同 ——JS 中很多方法（尤其是用于 “操作” 的方法，如添加事件、修改 DOM 等）都是 “只做事，不返回值” 的，`addEventListener` 就是典型代表。

  同理，你代码中的 `console.log(obj.add)` 也会输出 `undefined`，因为 `obj.add` 本质上是执行了 `addEventListener` 后的结果（同样是 `undefined`）。

  ------

  

### 7. 关于逻辑运算符&&

#### 7.1 `&&` 运算符的本质：返回 “表达式的结果”

在 JavaScript 中，`A && B` 的运算规则是：

- 先判断 `A` 是否为 “真”（truthy）
- 如果 `A` 为真，则返回 `B` 的结果
- 如果 `A` 为假，则返回 `A` 本身

它的作用是 “条件执行”，而不是 “存储函数”。

#### 7.2 总结

- `&&` 适合 “**立即执行一次，不需要后续操作**” 的场景（比如一次性绑定）。

- 函数包裹适合 “**需要手动触发、可能多次执行**” 的场景（比如通过对象方法控制绑定）。

- `&&` 是 “条件执行运算符”，它的结果是表达式的计算值（比如 `undefined`），而不是函数本身。
  如果你想在对象中存储 **“可以执行的逻辑”，必须用函数包裹** —— 这样属性存储的才是函数引用，后续才能通过 `对象.方法()` 调用。
            </div>
            <div id="scroll">
                <div id="bar"></div>
            </div>
        </div>
        <script>
            var oBox = $('#box');
            var oBox = $('#con');
            var oBox = $('#scroll');
            var oBox = $('#bar');
            
            // 获取dom元素的封装函数
            function $ (ele) {
                return document.querySelector(ele);
            }
        </script>
    </body>
</html>